theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-N/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*sum(log(y))
-1*log_lik
}
optim(c(-2,-2), foo, lower=c(-2,-2),upper=c(2,2), method="SANN")
optimize.bounds=c(-2,2)
nlminb(start = c(1,1), objective = foo,
lower = optimize.bounds[1], upper = optimize.bounds[2])
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH")
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
library(maxLik)
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH")
help(maxLik)
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH", print.level=2)
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
print(W_lambda)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
library(maxLik)
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH", print.level=2)
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
print(head(W_lambda))
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
library(maxLik)
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH", print.level=2)
foo <- function(params) {
theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
print(head(W_lambda))
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-N/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*sum(log(y))
-1*log_lik
}
nlminb(start = c(1,1), objective = foo,
lower = optimize.bounds[1], upper = optimize.bounds[2])
foo <- function(params) {
theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
print(lambda)
print(head(W_lambda))
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-N/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*sum(log(y))
-1*log_lik
}
nlminb(start = c(1,1), objective = foo,
lower = optimize.bounds[1], upper = optimize.bounds[2])
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
print(lambda)
print(head(W_lambda))
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH", print.level=2)
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
theta = max(-2,theta)
theta = min(2, theta)
lambda = max(-2, lambda)
lambda = min(2, lambda)
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
print(lambda)
print(head(W_lambda))
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH", print.level=2)
a
tanh(100)
tanh(-100)
a
vcov(a)
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
theta = 2*tanh(theta)
lambda = 2*tanh(lambda)
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
print(lambda)
print(head(W_lambda))
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
theta = 2*tanh(theta)
lambda = 2*tanh(lambda)
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH", print.level=2)
vcov(a)
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
theta = tanh(theta)
lambda = tanh(lambda)
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(log_lik)
}
library(maxLik)
a = maxLik(foo2, start = c(0.1988,0.63), method="BHHH", print.level=2)
vcov(a)
sqrt(diag(vcov(a)))
a = maxLik(foo2, start = c(0.1988,0.63), method="BFGS")
a
vcov(a)
sqrt(diag(vcov(a)))
a = maxLik(foo2, start = c(a=0.1988,b=0.63), method="BFGS")
deltaMethod(object, "tanh(a)", vcov. = vcov(a))
library(AER)
deltaMethod(object, "tanh(a)", vcov. = vcov(a))
deltaMethod(a, "tanh(a)", vcov. = vcov(a))
deltaMethod(a, "tanh(b)", vcov. = vcov(a))
deltaMethod(a, "tanh(a)", vcov. = abs(vcov(a)))
deltaMethod(a, "tanh(b)", vcov. = abs(vcov(a)))
library(RegUtils)
library(rio)
datos = import("http://www.stata-press.com/data/r13/nhanes2.dta")
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
library(rio)
datos = import("http://www.stata-press.com/data/r13/nhanes2.dta")
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
deltaMethod(a, "tanh(b)", vcov. = abs(vcov(a)))
deltaMethod(a, "tanh(b)", vcov. = abs(vcov(a)))$Estimate
a
a$maximum
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
nlminb(start = c(1,1), objective = foo2,
lower = optimize.bounds[1], upper = optimize.bounds[2])
nlminb(start = c(1,1), objective = foo,
lower = optimize.bounds[1], upper = optimize.bounds[2])
foo <- function(params) {
theta = params[1]
lambda = params[2]
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-N/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*sum(log(y))
-1*log_lik
}
help(nlminb)
nlminb(start = c(1,1), objective = -foo2,
lower = optimize.bounds[1], upper = optimize.bounds[2])
nlminb(start = c(1,1), objective = -1*foo2,
lower = optimize.bounds[1], upper = optimize.bounds[2])
nlminb(start = c(1,1), objective = foo2,
lower = optimize.bounds[1], upper = optimize.bounds[2])
foo2 <- function(params) {
theta = params[1]
lambda = params[2]
theta = tanh(theta)
lambda = tanh(lambda)
y = datos$bpdiast
x = cbind(datos$bmi, datos$tcresult)
z = cbind(datos$age, datos$sex)
box_cox <- function(x, lambda) {
if (!is.finite(lambda) || length(lambda) != 1)
stop("'lambda' must be a non-missing, finite numeric scalar")
if (any(x[!is.na(x)] <= 0))
stop("All non-missing values of 'x' must be positive")
return (apply(as.matrix(x), 1:2, function(x) if (abs(lambda)>.Machine$double.eps) (x^lambda-1)/lambda else log(x) ))
}
W_lambda = cbind(1,box_cox(x, lambda), z)
y_t = box_cox(y, theta)
N = length(y_t)
d_hat = solve(crossprod(W_lambda))%*%t(W_lambda)%*%y_t
sigma_sq_hat = 1/N*crossprod((y_t-W_lambda%*%d_hat))
log_lik = (-1/2)*(log(2*pi)+1+log(sigma_sq_hat))+(theta-1)*log(y)
return(-1*log_lik)
}
library(maxLik)
a = maxLik(foo2, start = c(a=0.1988,b=0.63), method="BFGS")
q
a
help(maxLik)
nlminb(start = c(1,1), objective = foo,
lower = optimize.bounds[1], upper = optimize.bounds[2])
a = maxLik(foo2, start = c(a=0.1988,b=0.63), method="BFGS",  control=list(fnscale=-1))
nlminb(start = c(1,1), objective = foo,
lower = optimize.bounds[1], upper = optimize.bounds[2], control=list(fnscale=-1))
help("nlminb")
library(RegUtils)
library(rio)
datos = import("http://www.stata-press.com/data/r13/nhanes2.dta")
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
library(rio)
datos = import("http://www.stata-press.com/data/r13/nhanes2.dta")
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
fit1
fit1$par
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
fit1
fit1$log_likelihood
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
deltaMethod(a, "tanh(a)", vcov. = abs(vcov(a)))
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
summary(boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"),
test.params = c(-1,-1)))
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
fit1$lambda.se
fit1$theta.se
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
fit2 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos,
noTrans=c("age","sex"), test.params = c(-1,-1))
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
fit2 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos,
noTrans=c("age","sex"), test.params = c(-1,-1))
summary(fit2)
fit1$theta
fit2$theta
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
fit2 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos,
noTrans=c("age","sex"), test.params = c(-1,-1))
summary(fit2)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"), model="lambda")
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"), model="lambda")
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"), model="lambda")
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"), model="lambda")
library(RegUtils)
summary(fit1)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"), model="rhs")
summary(fit1)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"), model="lhs")
summary(fit1)
library(RegUtils)
coefficients(fit1)
confint(fit1)
library(RegUtils)
library(RegUtils)
fit1 = boxcox.r(bpdiast~bmi+tcresult+age+sex, data=datos, noTrans=c("age","sex"))
summary(fit1)
coef(fit1)
confint(fit1)
(rio)
(rio)
(rio)
library(rio)
datos = import("http://www.stata-press.com/data/r13/union3.dta")
library(RegUtils)
fit1 = etreg(wage~age+grade+smsa+black+tenure,union~south+black+tenure,
data=datos)
summary(fit1)
fit1 = etreg(wage~1,data=datos)
fit1 = lm(wage~1,data=datos)
fit1
logLik(fit1)
(-3051.575+4155.67)*2
logLik(fit2)
fit2 = lm(wage~1,data=datos)
logLik(fit2)
(-3051.575+4155.67)*2
fit2 = lm(wage~age+grade+smsa+black+tenure+union,data=datos)
logLik(fit2)
(-3051.575+2469.342)*2
681.89/2
3051.57-340.945
fit2 = lm(wage~age+grade+smsa+black+tenure,data=datos)
logLik(fit2)
fit2 = lm(wage~age+grade+smsa+black,data=datos)
logLik(fit2)
(-3051.575+4155.67)*2
2208.19/6
